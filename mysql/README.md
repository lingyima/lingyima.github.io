# 电商数据库设计及架构优化实战

- 注册会员(用户模块) - 展示商品 - 加入购物车(购物车模块)-生成订单(订单模块)
- 商户入住(商户模块) - 发送货物(物流模块)

## 环境
- MySQL 5.7
- SQLyog: MySQL图形客户端程序


## 购物流程
用户登录->选购商品->加购物车->检车库存->提交订单
- 货到付款 	
	 + Y
	 + N => 订单付款
- 发货

## 用户模块
> 用户注册/登录验证/查找密码

## 商品模块
> 前后台商品管理和浏览

## 订单模块
> 订单/购物车的生成和管理 

## 仓配管理
> 仓库库存和物理的管理


## 数据结构设计
- 逻辑设计 -> 逻辑设计

- 实际工作：逻辑设计+物理设计


# 数据库设计规范
- 数据库命名规范
- 数据库基本设计规范
- 数据库索引设计规范
- 数据库字段设计规范
- 数据库 SQL 开发规范
- 数据库操作行为规范(运维)


## 数据库命名规范
- 所有数据库对象名称是**小写字母并用下划线分割**（Linux OS 区分大小写）
- 所有数据库对象名称禁止使用[MySQL保留关键字](https://dev.mysql.com/doc/refman/5.7/en/keywords.html)
- 所有数据库对象名称必须要**见名识义**，并且最好不超过32个字符
- 临时表：以tmp为前缀并以日期为后缀
- 备份表：以bak为前缀并以日期为后缀
- 所有存储**相同数据的列名和列类型必须一致**（不同列名影响性能）
-


- lym_userdb(零壹码网的用户数据库)
- user_account(用户账号表)

## 数据库基本设计规范
**MySQL 5.5 使用之前 MyISAM(默认存储引擎)**

- 所有表必须使用 **InnoDB** 存储引擎
	+ 5.6 + 默认引擎
	+ 支持事务，行级锁，更好恢复性，高并发下性能更好
- 数据库表和字符集统一使用UTF8
	+ 避免字符集转换乱码
	+ UTF—8字符集汉字占用3个字节
- 所有表和字段必须添加注释
	+ 便于以后数据字典的维护
- 尽量控制单表数据量大小，建议控制在500万以内
	+ 500万并不是 MySQL 数据库限制
	+ 存储多少万数据？取决于存储设置和文件系统
	+ 历史数据归档、分库分表(业务)等手段来控制数据量大小
- 谨慎使用 MySQL分区表
	+ 分区表在物理上表现为多个文件，在逻辑上表现为一个表
	+ 分区键，跨分区查询效率可能更低
	+ 建议才用物理分表的方式管理大数据

- 冷热数据分离，减少表的字段
	+ MySQL 限制做多存储4096列
	+ MySQL 每行不能超过65535字节
	+ 减少磁盘IO，保证热数据缓存命中率
	+ 利用更有效的利用缓存，避免读取无用的冷数据
	+ 经常一起使用的列放在一起

- 禁止在表中预留字段
	+ 见名识义
	+ 预留字段无法确认存储的数据类型，所有无法选择合适的类型
	+ 对预留字段类型的修改，会对表进行锁定
- 禁止存储图片/文件等二进制数据
- 禁止在线上做数据库压力测试（可以在开发环境测试）
- 禁止从开发环境，测试环境直连生产环境

## 索引设计规范
> 对查询性能非常重要

- 不要滥用索引
- 限制每张表的索引数量，建议单表索引不超过5个
	+ 与列数量成正比
	+ 索引提高效率同时可以降低效率
- InnoDB 表必须有一个主键
	+ 不适用更新频繁de列作为主键，不使用多列主键
	+ 不使用uuid,md5,hash,字符串列作为主键
- 使用自增ID值

- 常见索引列建议：
	+ select,update,delete语句的where从句中的列
	+ 包含在order by, group by, distinct中的字段
	+ 多表 join 的关联列

- 如何选择索引列的顺序
	+ 从左到右的顺序来使用
		* 区分度最高的列放在联合索引的最左侧
		* 尽量字段长度小的列放在联合索引的最左侧
		* 使用最频繁的列放到联合做引的左侧
	
- 避免建立冗余索引和重复索引
	+ index(a,b,c), index(a,b), index(a)

- 频繁查询有限考虑使用覆盖索引
	+ 覆盖索引：包含了素有查询字段的索引(where,order by, group by)
	+ 好处：
		* 避免innodb表进行索引的二次查找
		* 随机IO变为顺序IO加快查询效率

- 尽量避免使用外键
	+ 不建议使用外键约束
	+ 在业务端实现
	+ 外键影响父表和子表的写操作从而降低性能


## 数据库字段设计规范
- 优先选择符合存储需要的**最小的数据类型**
	+ inet_aton('255.255.255.255') = 4294967295
	+ inet_ntoa(4294967295) = '255.255.255.255'

	4 byte vs 15 byte	
- 选择非负整型数据选择无符号整型数据进行存储unsigned 类型
- varchar(n) n代表**字符数**，而不是字节数
	+ utf8汉字varchar(255) = 占用765 byte

- 过大的长度会消耗更多的内存
- 避免使用text(max 64k), blob数据类型
	+ tinytext
	+ text
	+ midumtext
	+ longtext
	+ 内存不支持text,blog 排序
	+ 需要二次查询
	+ 建议单独放到的扩展表中
	+ text/blog只能有前缀索引，没有默认值
- 避免使用enum数据类型
	+ 65535 中
	+ 字符串类型
	+ 修改enum值需要使用alter语句
	+ enum类型的order by 操作率低，需要额外的操作
	+ 禁止使用数值作为enum的枚举类型

- 尽可能吧所有列定义为NOT NULL
	+ 索引null列需要额外的空间来保存，所以要占用更多的空间
	+ 进行比较和计算时要对null值做特别的处理
- 使用timestamp(4 byte)或datetime(8 byte)类型存储时间
	+ timestamp 1970-01-01 00:00:01 ~ 2038-03-03 03:14:07
	+ timestamp占用 4 byte 和 int 相同，但比 int 可读性高
- 超出时间范围使用datetime
- 财务数据必须使用decimal
	+ 精准浮点数，在计算时不会丢失精度
	+ 占用空间由定义的宽度决定
		* 每4字节存储9位数据
	+ 存储比bigint更多的数据


## 数据库 SQL 开发规范
- **预编译语句**进行数据库操作
> prepare stmt1
> from 'select SQRT(POW(?,2) + POW(?,2)) AS hypotenuse';
> set @a=3;
> set @b=4;
> execute stmt1 USING @a, @b;
> deallocate prepare stmt1;

	+ 只传参数，比传递SQL语句更高效
	+ 相同语句可以一次解析，多次使用，提高处理效率

- 避免数据类型的隐式转换
	+ 隐式转换导致索引失效
	+ where id='1'

- 利用表上的已经存在的索引
	+ 避免使用双%好的查询条件：'%123%'
	+ 一个SQL只能利用到复合索引中的一列进行范围查询
	+ 使用 left join 和 not exists 来优化 not in 操作

- 不同的数据库使用不同的账号，禁止跨库查询
	+ 为数据库迁移和分库分表留出余地
	+ 降低业务耦合度
	+ 避免权限过大而产生的安全风险
- 禁止使用select*
	+ 消耗更多的CPU和IO以及网络带宽资源
	+ 无法使用覆盖索引
	+ 可以减少表结构变更带来的影响

- 禁止是不含字段列表的insert 语句
	+ insert int t value('a','b')
	+ insert into t(c1,c2) values('a','b')
	+ 可以减少结构变更带来的影响

- 禁止子查询，子查询优化位join操作
	+ 在查询结果集无法使用索引
	+ 产生临时表操作，如果子查询数据量大则严重影响效率
	+ 消耗过多的CPU和IO资源

- 避免使用join关联太多的表
	+ 每join一个表会多占用一部分内存(join_buffer_size)
	+ 会产生临时表操作，应影响查询效率
	+ MySQL 最多允许关联61个表，建议不超过5个

- 减少同数据库的交互次数
	+ 分页显示：不要提取 第一页结果
	+ 数据库更合适处理批量操作
	+ 合并多个相同的操作到一起，可以提高处理效果
	+ alter table t1 add column c1int, add. ...

- 使用 in 代替 or
	+ in 的值不要超过 500个
	+ in 操作可以有效的利用索引

- 禁止使用 order by rand() 进行随机排序
	+ 会把所有符合条件的数据装载到内存中进行排序
	+ 消耗大量的CPU和IO及内存资源
	+ 在程序中获取一个随机值，然后从数据库中获取数据

- where 从句中禁止对列进行函数转换和计算
	+ 导致无法使用索引
	+ where date(createtime) = '20160901'
	+ where createtime >= '20160901' and createtime < '20161010'

- 不会有重复值的使用union all ，而不是union
	+ union 把所有数据放到临时表中后再进行去重操作
	+ union all 不会再对结果集进行去重操作

- 拆分复杂的大 SQL 为多个小 SQL
	+ MySQL 一个 SQL 只能使用一个CPU进行计算
	+ 通过并行执行来提高处理效率

## 数据库操作行为规范(运维)
- 超 100万行的批量写操作，要分批多次进行操作
	+ 大批量操作可能造成严重的主从延迟
	+ binlog 日志为row格式时会产生大量的日志
	+ 避免产生大事务操作


- 对大表数据结构修改一定要谨慎，会造成严重的锁表操作。尤其是生产环境，是不能忍受的。 10分钟表锁，会出现在线延迟

- 对大表使用pt-online-schema-change修改表结构
	+ percona开发的工具
	+ 1. 新建表与原来表一样，并修改表结构
	+ 2. 复制数据到新表中，并在源表中增加触发器，把新增的数据也增加在新表中。在行的数据完成之后，在源表上加上事件锁

	+ 避免大表修改产生的主从延迟
	+ 避免在对表字段进行修改时进行锁表

- 禁止为程序程序使用的账号赋予super权限
	+ 当达到最大连接数限制时，还允许1个有super权限的用户连接
	+ super权限只能留给DBA 处理问题的账号使用

- 程序连接数据库账号，遵循权限最小原则
	+ 不准夸库
	+ 程序使用账号原则上不准有drop权限








## 数据库解决方案
